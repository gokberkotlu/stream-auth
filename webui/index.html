<!DOCTYPE html>
<html>
<head>
  <title>Real-Time Video Stream for Face Recognition</title>
  <style>
    video {
      width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <h1>Real-Time Video Stream for Face Recognition</h1>

  <video id="localVideo" autoplay></video>

  <script>
    let localStream;
    let localPeerConnection;
    let socket;

    const localVideoElement = document.getElementById('localVideo');

    // Function to start the stream
    async function startStream() {
      try {
        // Access the user's media devices
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        localVideoElement.srcObject = localStream;

        // Create a new RTCPeerConnection
        localPeerConnection = new RTCPeerConnection();

        // Add the local stream to the peer connection
        localStream.getTracks().forEach(track => {
          console.log("1");
          localPeerConnection.addTrack(track, localStream);
        });

        // Create an offer and set it as the local description
        localPeerConnection.createOffer()
          .then(offer => localPeerConnection.setLocalDescription(offer))
          .then(() => {
            console.log("2");
            // Send the offer to the server for signaling
            sendOffer(localPeerConnection.localDescription);
          })
          .catch(error => {
            console.log("3");
            console.error('Error creating offer:', error);
          });

        // Set up the WebSocket connection to the server for signaling
        socket = new WebSocket('ws://localhost:8080/ws');

        socket.onopen = () => {
          console.log('WebSocket connection opened');
        };

        socket.onmessage = (event) => {
          console.log("4");
          const message = JSON.parse(event.data);
          handleSignalingMessage(message);
        };

        // Function to send the offer to the server
        function sendOffer(offer) {
          console.log("5");
          // Send the offer to the server for signaling
          const message = {
            type: 'offer',
            sdp: offer.sdp
          };
          socket.send(JSON.stringify(message));
        }

        // Function to handle the incoming answer
        function handleAnswer(answer) {
          console.log("6");
          const remoteDescription = new RTCSessionDescription({ type: 'answer', sdp: answer.sdp });
          localPeerConnection.setRemoteDescription(remoteDescription);
        }

        // Function to send the ICE candidate to the server
        function sendICECandidate(candidate) {
          console.log("7");
          // Send the ICE candidate to the server for signaling
          const message = {
            type: 'candidate',
            candidate: candidate
          };
          socket.send(JSON.stringify(message));
        }

        // Function to handle the incoming ICE candidate
        function handleICECandidate(candidate) {
          console.log("8");
          const iceCandidate = new RTCIceCandidate(candidate);
          localPeerConnection.addIceCandidate(iceCandidate);
        }

        // Function to handle the received signaling message
        function handleSignalingMessage(message) {
          console.log("9");
          switch (message.type) {
            case 'answer':
              handleAnswer(message);
              break;
            case 'candidate':
              handleICECandidate(message.candidate);
              break;
            default:
              console.error('Invalid signaling message:', message);
          }
        }

        // Set up the RTCPeerConnection event handlers
        localPeerConnection.onicecandidate = (event) => {
          console.log("10");
          if (event.candidate) {
            // Send the ICE candidate to the server
            sendICECandidate(event.candidate);
          }
        };

        // Set up the RTCPeerConnection track event handler
        localPeerConnection.ontrack = (event) => {
          console.log("11");
          // Get the video track from the event
          const videoTrack = event.streams[0].getVideoTracks()[0];

          // Create a canvas to capture video frames
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');

          // Set the canvas dimensions to match the video track
          canvas.width = videoTrack.width;
          canvas.height = videoTrack.height;

          // Capture and send video frames at regular intervals
          setInterval(() => {
            console.log("TICK!");
            // Draw the current video frame onto the canvas
            context.drawImage(videoTrack, 0, 0, canvas.width, canvas.height);

            // Get the base64-encoded data URL of the canvas image
            const imageData = canvas.toDataURL('image/jpeg');

            // Send the image data to the server
            sendImageData(imageData);
          }, 100); // Adjust the interval as needed
        };

        // Function to send the image data to the server
        function sendImageData(imageData) {
          console.log("12");
          // Send the image data to the server using WebSocket
          console.log("sendImageData called");
          socket.send(imageData);
        }
      } catch (error) {
        console.error('Error accessing media devices:', error);
      }
    }

    // Start the stream when the page loads
    window.onload = () => {
      console.log("13");
      startStream();
    };
  </script>
</body>
</html>
